/* * Copyright the original author or authors. *  * Licensed under the MOZILLA PUBLIC LICENSE, Version 1.1 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.mozilla.org/MPL/MPL-1.1.html *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *//** * @author Francis Bourre * @version 1.0 */import com.bourre.commands.Delegate;import com.bourre.data.collections.Map;import com.bourre.data.libs.GraphicLib;import com.bourre.events.EventBroadcaster;import com.bourre.events.EventType;import com.bourre.events.StringEvent;import com.bourre.ioc.assembler.ApplicationAssembler;import com.bourre.ioc.assembler.DepthManager;import com.bourre.ioc.context.Context;import com.bourre.ioc.core.IDExpert;import com.bourre.ioc.events.PixiocSystemChannel;import com.bourre.ioc.log.PixiocDebug;import com.bourre.ioc.parser.ContextAttributeList;import com.bourre.ioc.parser.ContextNodeNameList;import com.bourre.ioc.parser.ContextTypeList;import com.bourre.ioc.parser.IContextParserListener;import com.bourre.ioc.parser.ReversedBatch;import com.bourre.log.PixlibStringifier;import com.bourre.log.PixlibDebug;class com.bourre.ioc.parser.ContextParser {	public static var onContextParsingEndEVENT : EventType = new EventType( "onContextParsingEnd" );		private var _oAssembler : ApplicationAssembler;	private var _oEB : EventBroadcaster;	private var _mNodeType : Map;	private var _oContext : Context;	public function ContextParser( assembler : ApplicationAssembler ) 	{		_oEB = new EventBroadcaster( this );		_oAssembler = assembler;				_mNodeType = new Map();		_mNodeType.put( ContextNodeNameList.APPLICATION_LOADER, _parseLoaderNode );		_mNodeType.put( ContextNodeNameList.DLL, _parseDLLNode );		_mNodeType.put( ContextNodeNameList.ROOT, _parseRootDisplayNode );		_mNodeType.put( ContextNodeNameList.BEANS, _parseRootLogicNode );	}	public function parse( context : Context ) : Void	{		_oContext = context;		_parseNode( ContextNodeNameList.APPLICATION_LOADER );	}		private function _parse() : Void	{		_parseNode( ContextNodeNameList.DLL );		_parseNode( ContextNodeNameList.ROOT );		_parseNode( ContextNodeNameList.BEANS );		_oEB.broadcastEvent( new StringEvent( ContextParser.onContextParsingEndEVENT ) );	}	private function _parseNode( nodeType : String ) : Void	{		if ( _oContext[ nodeType ] || nodeType == ContextNodeNameList.BEANS )		{			Function(_mNodeType.get( nodeType )).apply( this, [nodeType] );			_hideNode( nodeType );					} else if ( nodeType == ContextNodeNameList.APPLICATION_LOADER )		{			_parse();		}	}	private function _hideNode( nodeName : String ) : Void	{		_global.ASSetPropFlags( _oContext, nodeName, 7, 1);	}	private function _parseLoaderNode( nodeName : String ) : Void	{		var attribute = _oContext[ ContextNodeNameList.APPLICATION_LOADER ].attribute;		var url : String = ContextAttributeList.getURL( attribute );		var id : String = ContextAttributeList.getID( attribute );				if ( url )		{			var depth : Number = Number(ContextAttributeList.getDepth( attribute ));			var progressCallback : String = ContextAttributeList.getProgressCallback( attribute );			var nameCallback : String = ContextAttributeList.getNameCallback( attribute );			var timeoutCallback : String = ContextAttributeList.getTimeoutCallback( attribute );			var builtCallback : String = ContextAttributeList.getBuiltCallback( attribute );			var initCallback : String = ContextAttributeList.getInitCallback( attribute );						var gl : GraphicLib = _oAssembler.createLoader( id, url, depth, progressCallback, nameCallback, timeoutCallback, builtCallback, initCallback );			gl.addEventListener( GraphicLib.onLoadInitEVENT, this, _parse );			gl.execute();					} else		{			_parse();		}	}	private function _parseDLLNode( nodeName : String ) : Void	{		var dll = _oContext[ContextNodeNameList.DLL];		if ( dll.attribute.url )		{			_oAssembler.buildDLL( dll.attribute.url );					} else		{			var l : Number = dll.length;			while ( --l > -1 )			_oAssembler.buildDLL( dll[l].attribute.url );		}	}		private function _parseRootDisplayNode( nodeName : String ) : Void	{		_parseDisplayNode( nodeName, _oContext[ nodeName ], null );	}	private function _parseDisplayNode( nodeName : String, nodeContent : Object, parentID : String ) : Void	{		// Filter reserved nodes (ex: attribute)		if ( ContextNodeNameList.getInstance().nodeNameIsReserved( nodeName ) 				&& nodeName != ContextNodeNameList.ROOT )		return;				// Recursive parsing of Arrays.		var l : Number = nodeContent.length;				if ( l > 0 ) 		{			for ( var i : Number = 0; i < l; i++ )			_parseDisplayNode( nodeName, nodeContent[i], parentID );			return;		}		var attribute = nodeContent.attribute;				// Debug missing ids.		var id : String = ContextAttributeList.getID( attribute );				if ( !id && nodeName != ContextNodeNameList.ROOT )		{			PixiocDebug.getInstance().fatal( this + " encounters parsing error in displayList, '" + nodeName + "' ain't got any id attribute." );			return;		}		IDExpert.getInstance().register( id );		if ( parentID )		{			var url : String = ContextAttributeList.getURL( attribute );			var sDepth : String = ContextAttributeList.getDepth( attribute );			var visible : String = ContextAttributeList.getVisible( attribute );			var isVisible : Boolean = visible ? (visible == "true") : true;						// Evaluate depth with DepthManager providing context id information.			var depth : Number = DepthManager.getInstance().suscribeDepth( id, parentID, Number(sDepth) );			if ( url )			{				// If we need to load a swf file.				_oAssembler.buildGraphicLib( parentID, depth, isVisible, id, url );							} else			{				// If we need to build an empty MovieClip.				_oAssembler.buildEmptyMovieClip( parentID, id, depth );			}		}				// Build property.		var propertyNode = nodeContent[ContextNodeNameList.PROPERTY];		if ( propertyNode )		_oAssembler.buildGraphicProperty( id, propertyNode );				// Build method call.		var methodCallNode = nodeContent[ContextNodeNameList.METHOD_CALL];		if ( methodCallNode )		_oAssembler.buildMethodCall( id, methodCallNode );				// recursivity		var b : ReversedBatch = new ReversedBatch();		for ( var p : String in nodeContent )		b.addCommand( new Delegate( this, _parseDisplayNode, p, nodeContent[p], id) );		b.execute();	}		private function _parseRootLogicNode( nodename : String ) : Void	{		for ( var p : String in _oContext ) _parseLogicNode( p, _oContext[p] );	}	private function _parseLogicNode( nodeName : String, nodeContent : Object ) : Void	{		// Recursive parsing of Arrays.		var l : Number = nodeContent.length;				if ( l > 0 ) 		{			for ( var i : Number = 0; i < l; i++ )			_parseLogicNode( nodeName, nodeContent[i] );			return;		}		var attribute = nodeContent.attribute;				// Debug missing ids.		var id : String = ContextAttributeList.getID( attribute );				if ( !id )		{			PixiocDebug.getInstance().fatal( this + " encounters parsing error with '" + nodeName + "' node. You must set an id attribute." );			return;		}		IDExpert.getInstance().register( id );		// Build object.		var type : String = ContextAttributeList.getType( attribute );		type = type ? type : ContextTypeList.STRING;		var factory : String = ContextAttributeList.getFactoryMethod( attribute );		var singleton : String = ContextAttributeList.getSingletonAccess( attribute );		var channel : String = ContextAttributeList.getChannel( attribute );		var args = nodeContent[ContextNodeNameList.ARGUMENT];				if ( args == undefined )		{			var value : String = ContextAttributeList.getValue(attribute);			if ( value != undefined) 			{				args = new Object();				args.attribute = {type:type, value:value};			}		}				_oAssembler.buildObject( id, type, args, factory, singleton, channel );				// register each object to system channel.		_oAssembler.buildChannelListener( id, PixiocSystemChannel.CHANNEL );				// Build property.		var propertyNode = nodeContent[ContextNodeNameList.PROPERTY];		if ( propertyNode )		_oAssembler.buildProperty( id, propertyNode );		// Build method call.		var methodCallNode = nodeContent[ContextNodeNameList.METHOD_CALL];		if ( methodCallNode )		_oAssembler.buildMethodCall( id, methodCallNode );				// Build channel listener.		var listenChannelNode = nodeContent[ContextNodeNameList.LISTEN];		if ( listenChannelNode )		_oAssembler.buildChannelListener( id, listenChannelNode );	}		/**	 * Event system	 */	public function addListener( oL : IContextParserListener ) : Void	{		_oEB.addListener( oL );	}		public function removeListener( oL : IContextParserListener ) : Void	{		_oEB.removeListener( oL );	}		public function addEventListener( e : EventType, oL, f : Function ) : Void	{		_oEB.addEventListener.apply( _oEB, arguments );	}		public function removeEventListener( e : EventType, oL ) : Void	{		_oEB.removeEventListener( e, oL );	}		/**	 * Returns the string representation of this instance.	 * @return the string representation of this instance	 */	public function toString() : String 	{		return PixlibStringifier.stringify( this );	}}