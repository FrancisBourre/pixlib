/* * Copyright the original author or authors. *  * Licensed under the MOZILLA PUBLIC LICENSE, Version 1.1 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.mozilla.org/MPL/MPL-1.1.html *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. *//** * @author Francis Bourre * @version 1.0 */import com.bourre.events.EventBroadcaster;import com.bourre.events.EventType;import com.bourre.ioc.assembler.method.IMethodExpertListener;import com.bourre.ioc.assembler.method.Method;import com.bourre.ioc.assembler.method.MethodEvent;import com.bourre.ioc.assembler.property.PropertyExpert;import com.bourre.ioc.bean.BeanFactory;import com.bourre.ioc.parser.ContextAttributeList;import com.bourre.ioc.parser.ContextNodeNameList;import com.bourre.log.PixlibDebug;import com.bourre.log.PixlibStringifier;class com.bourre.ioc.assembler.method.MethodExpert 	extends Method{	private static var _oI : MethodExpert;	private var _oEB : EventBroadcaster;	private var _aMethod : Array;		/**	 * @return singleton instance of MethodExpert	 */	public static function getInstance() : MethodExpert 	{		if (!_oI) _oI = new MethodExpert();		return _oI;	}		private function MethodExpert()	{		_oEB = new EventBroadcaster( this );		_aMethod = new Array();	}		public function buildMethod( ownerID : String, method ) : Void	{		var l : Number = method.length;		if ( l > 0 ) 		{			for ( var i : Number = 0; i < l; i++ ) _aMethod.push( _buildMethod( ownerID, method[i] ) );					} else		{			_aMethod.push( _buildMethod( ownerID, method ) );		}	}		private function _buildMethod( ownerID : String, rawMethod : Object ) : Method	{		var m : Method =  new Method	( 												ownerID,											ContextAttributeList.getName( rawMethod.attribute ),											PropertyExpert.getInstance().getPropertyVO( ownerID, rawMethod[ContextNodeNameList.ARGUMENT] )										);													_oEB.broadcastEvent( new MethodEvent() );		return m;	}		public function callMethod( m : Method ) : Void	{		var owner = BeanFactory.getInstance().locate( m._sOwnerID );		var f : Function = owner[ m._sName ];				if (f)		{			owner[ m._sName ].apply( owner, PropertyExpert.getInstance().deserializeArguments( m._aArgs ) );		} else		{			PixlibDebug.FATAL( this + ".callMethod() failed. " + m._sOwnerID + "." + m._sName + "() can't be called." );		}	}		public function callAllMethods() : Void	{		var l : Number = _aMethod.length;		for ( var i : Number = 0; i < l; i++ ) callMethod( _aMethod[i] );	}		/**	 * Event system	 */	public function addListener( oL : IMethodExpertListener ) : Void	{		_oEB.addListener( oL );	}		public function removeListener( oL : IMethodExpertListener ) : Void	{		_oEB.removeListener( oL );	}		public function addEventListener( e : EventType, oL, f : Function ) : Void	{		_oEB.addEventListener.apply( _oEB, arguments );	}		public function removeEventListener( e : EventType, oL ) : Void	{		_oEB.removeEventListener( e, oL );	}		/**	 * Returns the string representation of this instance.	 * @return the string representation of this instance	 */	public function toString() : String 	{		return PixlibStringifier.stringify( this );	}}